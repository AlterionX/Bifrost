## Structure ##

Note the package names. Many classes are still unlisted.

### Data management - AST and Symbol Table (yggdrasil) ###

#### Yggdrasil ####

The AST structure of the parser. This is populated and modified during the parsing stage. It will be reference throughout the analytic stage.

The AST is the central class, as well, and is required by all the other classes.

#### Nidhogg ####

The symbol table of the parser. This is only populated after parsing, during the first analytic stage, and is paired with the AST.

### RegEx Engine (bragi) ###

This has a simple interface for RegEx verification, as well as matching RegEx expressions.

#### SkaldComponent ####

This is the core of the RegEx engine. The RegEx is initially broken down into these sub-components.

#### Skald ####

Meaning poet, it is a surprisingly fitting name for the main body of the RegEx engine. It parses input RegEx and sends it off to various other SkaldComponents to be handled and returned.

#### Stef ####

These are the nodes of the DFAs and NFAs generated by Skald after it finishes parsing through the RegEx. These do a surprisingly large quantity of tasks, one of which is to handle lookarounds. They can be augmented to handle captures and backtracking, but have not been yet.

#### Lausavisa ####

The NFA of the RegEx engine. A fitting name for the disconnectedness (or overconnectedness) of NFAs, it represents a single, long winded, but far shorter version of the DFA. Otherwise know as the NFA.

#### Drottkvaet ####

The staple stanza of the Drapa, it is a series of states interspersed with computing. It holds the DFA that represents a RegEx and is generated from the NFA.

### Lexer (niflheim) ###

#### Hel ####

Hel manages the lexers, generating them and matching the input with the lexers, selecting the best (first) match. It will pass these back to Helvegar.

#### Helvegar ####

The public face of the Lexer. All constructing from non-package sources will use Helvegar to produce the lexer.

### Parser (midgard) ###

#### Jormungandr ####

The main parser front end. Incoming communication will be filtered through Jormungandr. It also manages the data state of the parser, making requests of Skadi.

#### Skadi ####

This manages the rules back end and generates the parsing tables. It will initialize the various grammar constructs used.

#### CFG ####

The managers of the context free language. While Skadi manages the traffic between the two and Jormungandr deals with the queries, this one does all the work.

### Analyzer (asgard) ###

#### Heimdallr ####

The guard of Asgard, this also checks the semantic meanings behind the provided texts, modifying the symbol table Nidhogg, and finalizing the grammar before it can be compiled into intermediate code.

#### Hoenir ####

This being is said to have given meaning to man, and so will give meaning to the program. It traverses the AST, composing the final intermediate code. Optimization will also be dealt with by this Class.

### Assembly generator (muspelheim) ###

#### Surtr ####

This will take a machine description file and compile code based on the register-memory view of the machine.

#### Machine ####

This class will hold the description of the machine, as well as a list of generated rules.

## Specifications ##

### Regex limitations ###

Back references are not yet be supported.

The full list of operations supported:

* Dot operator: Matches any character</li>
* Character Sets: A set of characters</li>
* Negated sets: A negated set of characters
* Ranged sets: A range. These can be scattered liberally, and will include all letters that the alphabet places between the two letters. For example, if your alphabet were `ABCDEFGHIJKLMNOZPQRSTUVWXY`, the set `\[A-Z\]` will encompass `ABCDEFGHIJKLMNOZ`, but not `PQRSTUVWXY`
* Lookarounds: Checks after a regex match if the regex is valid
  * Positive lookahead: only matches if the regex provided is matched immediately after the first match
  * Negative lookahead: only matches if the regex provided is not matched immediately after the first match
  * Positive lookbehind: only matches if the regex provided is matched immediately before the first match
  * Negative lookbehind: only matches if the regex provided is not matched immediately before the first match
  
   Lookbehinds are implemented by flipping the regex and analyzing the text in reverse order.
* Kleene Star: A zero or more repetition
* Presence: A zero or one occurence
* Kleene Plus: A one or more repetition
* Bracketed repetition: A repetition of the form `{n}`, `{n,m}`, or `{n,}`, representing `n` repetitions, `n` to `m` repetitions, and more than `n` repetitions of the preceding regex
* Union operator: One regex or another

The leftmost column is precedence.

|  P  |        Regex       |         Syntax          |
|:---:|:------------------:|:-----------------------:|
|  0  |Dot operator        |`.`                      |
|  0  |Character Sets      |`[abc]`                  |
|  0  |Negated sets        |`[^abc]`                 |
|  0  |Ranged sets         |`[a-c]`                  |
|  0  |Positive lookahead  |`(?=a)`                  |
|  0  |Positive lookbehind |`(?<=a)`                 |
|  0  |Negative lookahead  |`(?!a)`                  |
|  0  |Negative lookbehind |`(?<!a)`                 |
|  1  |Kleene Star         |`a*`                     |
|  1  |Plus                |`a+`                     |
|  1  |Presence            |`a?`                     |
|  1  |Bracketed repetition|`a{1,2}`                 |
|  2  |Union operator      | <code>a&#124;b</code>   |

### Lexer declaration file format ###

The lexer definition file will be named "`compiler name`.lexdec".

There exists predefined alphabets, as follows:

|  Name:  |Alphabet characters|
|---------|-------------------|
|`DEFAULT`|<code>\t\n\r !\"#$%&'()*+,-./<br >0123456789<br >:;<=>?@<br >ABCDEFGHIJKLMNOPQRSTUVWXYZ<br >[\\]^_`<br >abcdefghijklmnopqrstuvwxyz<br >{&#124;}~</code>|

Note that `\n`, `\t`, and `\r` are stand ins for newline, tab, and carriage return.

As Unicode is not supported, this is the only truly necessary alphabet. Another alphabet is needed only if you need to make the system more restrictive, or to modify the way range works in the regex system.

Lines after are listed as such `TOKEN_NAME: "token regex"` where the token regex stands for the regex used to match the said token.

Note that the token name can only be composed of the characters `A-Z_`, following the regex `[A-Z][A-Z_]*`.

Some rules will begin with a `%`. These are command rules. The remainder of the rule shall follow the same syntax analysis as the token rules.

Comments can only be on their own lines and shall be prefixed with `#`. Empty lines are ignored.

So each full rule can be parsed with the rather simplistic regex `(%?[A-Z]+: [^\n]*\n)|(#[^\n]*\n)`.

To resolve ambiguity in token matching, the FIRST rule that results in a match will be used.

### Parser declaration file format ###

The parser will build an AST tree, but only an AST tree and nothing else. It will allow for expansion and shrinking of the tree in the format.

It will take in rules of the SBNF format, or Simplified Backus-Naur Format. The format, as well as methods of node manipulation, are described below. More formats have been in the works, but only SBNF works for now.

#### Available node manipulations ####

These rules can be included within the lines, and are referred to as `CMD_TOKEN`s.

|Rule recognition    |Performance                              |
|--------------------|-----------------------------------------|
|`%LVL:-?[0-9]+`     |This modifies the level of the children of the node and the node itself that came immediately before that would have been what immediately came ahead of the `CMD_TOKEN`|
|`%RMV`              |Removes the immediately proceeding token from the tree|
|`%POP:[0-9]+:[a-zA-Z][a-zA-Z0-9_]*`|Pops off the provided number of nodes immediately preceeding this token and add them to the tree as a secondary node, with the tag being as provided. The new node name must be declared elsewhere, as well.|
NOTE: for `%LVL`, only -1 works at the moment. It is undefined for all other numerals.

#### Simplified Backus-Naur Form ####

Rules can span only a single line, and may consist of a series of command tokens interspersed with normal variable tokens. Command tokens begin with a `%`, and any arguments are `:` delimited. Every token must be white-space delimited.

More specifically, each rule is begun by a single `TOKEN` followed by a single `->`. Each right hand side will consist of a simple series of `TOKEN`s, interspersed with `CMD_TOKEN`s. The regex for matching a `TOKEN` is `[A-Z_]+`, while the `CMD_TOKEN`s are matched by `%[A-Z_]+(:[A-Z0-9_])*`. A single rule, therefore, is matched by `([A-Z_]+[\t\r ]+->((%[A-Z_]+(:(([A-Z0-9_]+)|(-?[0-9]+)))*)|([A-Z_]+))+)(?=\n|$)`. Additional comments may be made by utilizing a `#` at the beginning of a line, matched by `[\n\t\r ]*#[^\n]*(?=\n|$)`

Additional parser configuration rules are available. These must be set at the start of the first non-empty line of the file, as well as being in the exact order as listed, barring ones that were left out. The available parser configuration rules are as follows: `>PARSER_CLASS` and `>GRAMMAR_TYPE`. These maybe followed by \[`LR0`, `SLR`, `LALR`, `LR1`, and `GLR`\] or \[`SBNF`, `BNF`, `EBNF`, `CNF`, `CFG`\], respectively. However, only `LR0`, `SLR`, and `SBNF` are supported. The others are in development.

### Semantic Analyzer declaration file format ###

One optional line at the head of the file that must begin with `PATH=` will allow the configuration of the base directory of the java source files. The necessary source files will then be listed in package format, as if the package were at the base directory, without the .java extension, and with the dots replaced by either or both \ or `/`. The path provided will be appended with .java for the source file, and have the slashes replaced with `.` for the package name.

The named classes will be compiled and loaded at runtime for use in the order that they have been declared.

### Scope resolution declaration file format ###

This is essentially a list of all scope changes within a language. When the tree walker reaches one of the listings, it will go down a level. The `%CASE` is meant for a top-level node, and the scope changer will go down a new scope on trigger before `onUpEnter`, and go up a scope after `onUpExit`. The `%CHILD` is meant for triggers that occur when the presented `CHILD` is a child of the previous `PARENT`, in the previous `%CASE` statement. As such, the scope changer will go down to a new scope when the branch matches the `PARENT` and the child matches the `CHILD` before a call to `onDownEnter`. It will likewise go up a level after `onDownExit` if it had previously delved into a scope.

Every separate declaration must be made on a new line.

### Intermediate representation declaration ###

An optional line at the beginning, if written, begins with `>`, and will redirect the output of the code to the provided path, such that %s will be replaced by the entire file name of the file being translated on output. All rules must be on their own line.

Separate decoding schemes for a single node tag will be grouped between a single `/DECODE TAG_NAME` and a single `\END`. Within these blocks, each separate case must be surrounded by `/COND NUMBER TAG` and `/END`. This means that the set of direct mapping rules listed within the block will be used upon the `NUMBER` child of the parent node `TAG_NAME` being equivalent to `TAG`. Nested condition statements are not allowed. Condition statements must be provided. `/CATCHALL` is allowed per variable, and only allowed once per `/DECODE` block.

The statements of a conditional block must have the first rule be a production rule, one of the form `%F: .*` where `.*` would be the rule. This will be a reference for the first parent node to refer to this child node. There can be only one production rule per conditional block.

The way this works is similar to simple substitution of strings for their matching counter parts.

Several variables are provided. `%NUMBER` means to take the production generated by the above production rule of the `NUMBER`th child node of the current node. `%F` is used to refer reflexively/recursively to itself, as generated by its own production rule. A variety of linear number generators are provided. These may be accessed by using the for `%GE.` where `.` is the character for the generator. Currently there are only generators for `N`, `V`, and `F`. `%~` can be used only for terminal nodes, and are used to refer to the substring reference of themselves, as matched by the lexer. All other characters will be printed as is for the intermediate code translation.

### Machine representation declaration ###

In the works. Nothing is defined. But there's a working draft in the tyrion subdirectory.

### Assembler call declaration file ###

This file should hold a single line of the intended system call to the compiler. The files to be passed to the compiler will be appended automatically.
